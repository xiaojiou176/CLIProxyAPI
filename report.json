{"stats":{"totalMutantsCount":33,"killedCount":20,"notCoveredCount":0,"escapedCount":13,"errorCount":0,"skippedCount":0,"timeOutCount":0,"msi":0.6060606060606061,"mutationCodeCoverage":0,"coveredCodeMsi":0},"escaped":[{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":68},"diff":"--- Original\n+++ New\n@@ -65,7 +65,7 @@\n // For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\n func ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n \tif rawSuffix == \"\" {\n-\t\treturn 0, false\n+\n \t}\n \n \tvalue, err := strconv.Atoi(rawSuffix)\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.13\" with checksum c153110479bb22e498018e9954eeb255\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":73},"diff":"--- Original\n+++ New\n@@ -70,7 +70,7 @@\n \n \tvalue, err := strconv.Atoi(rawSuffix)\n \tif err != nil {\n-\t\treturn 0, false\n+\n \t}\n \n \t// Negative numbers are not valid numeric suffixes\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.14\" with checksum ff4d2a9e21d4059501730696dcb979ca\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\t_ = ModeBudget\n\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":95},"diff":"--- Original\n+++ New\n@@ -92,7 +92,8 @@\n // String values are case-insensitive.\n func ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n \tif rawSuffix == \"\" {\n-\t\treturn ModeBudget, false\n+\t\t_ = ModeBudget\n+\n \t}\n \n \t// Case-insensitive matching\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.16\" with checksum b9065a99d0b529993acf808f1327cb60\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":128},"diff":"--- Original\n+++ New\n@@ -125,7 +125,7 @@\n //   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\n func ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n \tif rawSuffix == \"\" {\n-\t\treturn \"\", false\n+\n \t}\n \n \t// Case-insensitive matching\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.17\" with checksum a98fb08cd7cf7df807c9904c1aba15f5\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c= 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ -75,7 +75,7 @@\n \n \t// Negative numbers are not valid numeric suffixes\n \t// -1 should be handled by special value parsing as \"auto\"\n-\tif value \u003c 0 {\n+\tif value \u003c= 0 {\n \t\treturn 0, false\n \t}\n \n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.18\" with checksum 08be9749ede269e711a293a4fedbdf70\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn -1, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":68},"diff":"--- Original\n+++ New\n@@ -65,7 +65,7 @@\n // For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\n func ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n \tif rawSuffix == \"\" {\n-\t\treturn 0, false\n+\t\treturn -1, false\n \t}\n \n \tvalue, err := strconv.Atoi(rawSuffix)\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.22\" with checksum 2ad30ac811411d7474f197829dcb2a58\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn -1, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":73},"diff":"--- Original\n+++ New\n@@ -70,7 +70,7 @@\n \n \tvalue, err := strconv.Atoi(rawSuffix)\n \tif err != nil {\n-\t\treturn 0, false\n+\t\treturn -1, false\n \t}\n \n \t// Negative numbers are not valid numeric suffixes\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.23\" with checksum ae1bbcc7bcd82180418b121fdf18d145\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c -1 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ -75,7 +75,7 @@\n \n \t// Negative numbers are not valid numeric suffixes\n \t// -1 should be handled by special value parsing as \"auto\"\n-\tif value \u003c 0 {\n+\tif value \u003c -1 {\n \t\treturn 0, false\n \t}\n \n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.24\" with checksum 5a2e6633f91c3e6af7fe61bfff96d964\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn -1, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":79},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \t// Negative numbers are not valid numeric suffixes\n \t// -1 should be handled by special value parsing as \"auto\"\n \tif value \u003c 0 {\n-\t\treturn 0, false\n+\t\treturn -1, false\n \t}\n \n \treturn value, true\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.25\" with checksum f7b31d96aea63153b9fb15b5738aef72\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 1, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":68},"diff":"--- Original\n+++ New\n@@ -65,7 +65,7 @@\n // For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\n func ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n \tif rawSuffix == \"\" {\n-\t\treturn 0, false\n+\t\treturn 1, false\n \t}\n \n \tvalue, err := strconv.Atoi(rawSuffix)\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.29\" with checksum 4ca7c7a92cbb6b11449929ccaf3383f1\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 1, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":73},"diff":"--- Original\n+++ New\n@@ -70,7 +70,7 @@\n \n \tvalue, err := strconv.Atoi(rawSuffix)\n \tif err != nil {\n-\t\treturn 0, false\n+\t\treturn 1, false\n \t}\n \n \t// Negative numbers are not valid numeric suffixes\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.30\" with checksum 252e26e1ab71e3765d762afecd87d75b\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 1 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ -75,7 +75,7 @@\n \n \t// Negative numbers are not valid numeric suffixes\n \t// -1 should be handled by special value parsing as \"auto\"\n-\tif value \u003c 0 {\n+\tif value \u003c 1 {\n \t\treturn 0, false\n \t}\n \n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.31\" with checksum e70b3f342141d851b79c1e566ed6be90\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 1, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":79},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \t// Negative numbers are not valid numeric suffixes\n \t// -1 should be handled by special value parsing as \"auto\"\n \tif value \u003c 0 {\n-\t\treturn 0, false\n+\t\treturn 1, false\n \t}\n \n \treturn value, true\n","processOutput":"FAIL \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.32\" with checksum 27e96a9117eef3842601478f01c58869\n"}],"timeouted":null,"killed":[{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen-1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \t// Extract components\n \tmodelName := model[:lastOpen]\n-\trawSuffix := model[lastOpen+1 : len(model)-1]\n+\trawSuffix := model[lastOpen-1 : len(model)-1]\n \n \treturn SuffixResult{\n \t\tModelName: modelName,\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.0\" with checksum a8529ce6c43ffce0d1750752312d672f\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)+1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \t// Extract components\n \tmodelName := model[:lastOpen]\n-\trawSuffix := model[lastOpen+1 : len(model)-1]\n+\trawSuffix := model[lastOpen+1 : len(model)+1]\n \n \treturn SuffixResult{\n \t\tModelName: modelName,\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.1\" with checksum 5a5e1eb35f84eb8ad9f727b5071797f5\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\t_ = ModeNone\n\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":101},"diff":"--- Original\n+++ New\n@@ -98,7 +98,8 @@\n \t// Case-insensitive matching\n \tswitch strings.ToLower(rawSuffix) {\n \tcase \"none\":\n-\t\treturn ModeNone, true\n+\t\t_ = ModeNone\n+\n \tcase \"auto\", \"-1\":\n \t\treturn ModeAuto, true\n \tdefault:\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.2\" with checksum e13ea81f5a599b773ecf74e240da2c6c\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\t_ = ModeAuto\n\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":103},"diff":"--- Original\n+++ New\n@@ -100,7 +100,8 @@\n \tcase \"none\":\n \t\treturn ModeNone, true\n \tcase \"auto\", \"-1\":\n-\t\treturn ModeAuto, true\n+\t\t_ = ModeAuto\n+\n \tdefault:\n \t\treturn ModeBudget, false\n \t}\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.3\" with checksum 817aaad9d3b5905f9a58d7f45068e630\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\t_ = ModeBudget\n\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":105},"diff":"--- Original\n+++ New\n@@ -102,7 +102,8 @@\n \tcase \"auto\", \"-1\":\n \t\treturn ModeAuto, true\n \tdefault:\n-\t\treturn ModeBudget, false\n+\t\t_ = ModeBudget\n+\n \t}\n }\n \n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.4\" with checksum 5f9c4838cf259de97aff8c5693d3b29a\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\t_ = LevelMinimal\n\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":134},"diff":"--- Original\n+++ New\n@@ -131,7 +131,8 @@\n \t// Case-insensitive matching\n \tswitch strings.ToLower(rawSuffix) {\n \tcase \"minimal\":\n-\t\treturn LevelMinimal, true\n+\t\t_ = LevelMinimal\n+\n \tcase \"low\":\n \t\treturn LevelLow, true\n \tcase \"medium\":\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.5\" with checksum 084503af91ab60efc03d8708cd33d6db\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\t_ = LevelLow\n\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":136},"diff":"--- Original\n+++ New\n@@ -133,7 +133,8 @@\n \tcase \"minimal\":\n \t\treturn LevelMinimal, true\n \tcase \"low\":\n-\t\treturn LevelLow, true\n+\t\t_ = LevelLow\n+\n \tcase \"medium\":\n \t\treturn LevelMedium, true\n \tcase \"high\":\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.6\" with checksum 8e4ba9b61ff52c631df5a6413d3894c8\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\t_ = LevelMedium\n\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":138},"diff":"--- Original\n+++ New\n@@ -135,7 +135,8 @@\n \tcase \"low\":\n \t\treturn LevelLow, true\n \tcase \"medium\":\n-\t\treturn LevelMedium, true\n+\t\t_ = LevelMedium\n+\n \tcase \"high\":\n \t\treturn LevelHigh, true\n \tcase \"xhigh\":\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.7\" with checksum 535eea2d2a1b92e77c550bff4dc4995c\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\t_ = LevelHigh\n\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":140},"diff":"--- Original\n+++ New\n@@ -137,7 +137,8 @@\n \tcase \"medium\":\n \t\treturn LevelMedium, true\n \tcase \"high\":\n-\t\treturn LevelHigh, true\n+\t\t_ = LevelHigh\n+\n \tcase \"xhigh\":\n \t\treturn LevelXHigh, true\n \tdefault:\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.8\" with checksum 30db7d92bafbf2093b89ba9a3d6bcdc0\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\t_ = LevelXHigh\n\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":142},"diff":"--- Original\n+++ New\n@@ -139,7 +139,8 @@\n \tcase \"high\":\n \t\treturn LevelHigh, true\n \tcase \"xhigh\":\n-\t\treturn LevelXHigh, true\n+\t\t_ = LevelXHigh\n+\n \tdefault:\n \t\treturn \"\", false\n \t}\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.9\" with checksum c4f0e73790e0dbd903147daafbe5db9d\n"},{"mutator":{"mutatorName":"branch/case","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":144},"diff":"--- Original\n+++ New\n@@ -141,6 +141,6 @@\n \tcase \"xhigh\":\n \t\treturn LevelXHigh, true\n \tdefault:\n-\t\treturn \"\", false\n+\n \t}\n }\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.10\" with checksum 306e9432361593c723b76210283d96bd\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\t_, _, _, _ = SuffixResult, ModelName, model, HasSuffix\n\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":27},"diff":"--- Original\n+++ New\n@@ -24,7 +24,8 @@\n \t// Find the last opening parenthesis\n \tlastOpen := strings.LastIndex(model, \"(\")\n \tif lastOpen == -1 {\n-\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n+\t\t_, _, _, _ = SuffixResult, ModelName, model, HasSuffix\n+\n \t}\n \n \t// Check if the string ends with a closing parenthesis\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.11\" with checksum ada502cbff00eae8fcc520e9962ec655\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\t_, _, _, _ = SuffixResult, ModelName, model, HasSuffix\n\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":32},"diff":"--- Original\n+++ New\n@@ -29,7 +29,8 @@\n \n \t// Check if the string ends with a closing parenthesis\n \tif !strings.HasSuffix(model, \")\") {\n-\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n+\t\t_, _, _, _ = SuffixResult, ModelName, model, HasSuffix\n+\n \t}\n \n \t// Extract components\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.12\" with checksum 0ec68ed772b37a3bfa61d25a7737cbca\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":79},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \t// Negative numbers are not valid numeric suffixes\n \t// -1 should be handled by special value parsing as \"auto\"\n \tif value \u003c 0 {\n-\t\treturn 0, false\n+\n \t}\n \n \treturn value, true\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.15\" with checksum d4e4e4d265bc896ee08461bd0514b9e4\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -0 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":26},"diff":"--- Original\n+++ New\n@@ -23,7 +23,7 @@\n func ParseSuffix(model string) SuffixResult {\n \t// Find the last opening parenthesis\n \tlastOpen := strings.LastIndex(model, \"(\")\n-\tif lastOpen == -1 {\n+\tif lastOpen == -0 {\n \t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n \t}\n \n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.19\" with checksum 3a528b64cc6abdddf3892a1e7fefcec5\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+0 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \t// Extract components\n \tmodelName := model[:lastOpen]\n-\trawSuffix := model[lastOpen+1 : len(model)-1]\n+\trawSuffix := model[lastOpen+0 : len(model)-1]\n \n \treturn SuffixResult{\n \t\tModelName: modelName,\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.20\" with checksum 758b0cdc859d716e34b599b2b8ba9e01\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-0]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \t// Extract components\n \tmodelName := model[:lastOpen]\n-\trawSuffix := model[lastOpen+1 : len(model)-1]\n+\trawSuffix := model[lastOpen+1 : len(model)-0]\n \n \treturn SuffixResult{\n \t\tModelName: modelName,\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.21\" with checksum 1e567bd6886ff591594a548953187b23\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -2 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":26},"diff":"--- Original\n+++ New\n@@ -23,7 +23,7 @@\n func ParseSuffix(model string) SuffixResult {\n \t// Find the last opening parenthesis\n \tlastOpen := strings.LastIndex(model, \"(\")\n-\tif lastOpen == -1 {\n+\tif lastOpen == -2 {\n \t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n \t}\n \n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.26\" with checksum abf64f336ed9d128cecc08d4e04f7a3a\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+2 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \t// Extract components\n \tmodelName := model[:lastOpen]\n-\trawSuffix := model[lastOpen+1 : len(model)-1]\n+\trawSuffix := model[lastOpen+2 : len(model)-1]\n \n \treturn SuffixResult{\n \t\tModelName: modelName,\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.27\" with checksum 2f0df9f28d21818f813e14bd83af7bc4\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-1]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","mutatedSourceCode":"// Package thinking provides unified thinking configuration processing.\n//\n// This file implements suffix parsing functionality for extracting\n// thinking configuration from model names in the format model(value).\npackage thinking\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseSuffix extracts thinking suffix from a model name.\n//\n// The suffix format is: model-name(value)\n// Examples:\n//   - \"claude-sonnet-4-5(16384)\" -\u003e ModelName=\"claude-sonnet-4-5\", RawSuffix=\"16384\"\n//   - \"gpt-5.2(high)\" -\u003e ModelName=\"gpt-5.2\", RawSuffix=\"high\"\n//   - \"gemini-2.5-pro\" -\u003e ModelName=\"gemini-2.5-pro\", HasSuffix=false\n//\n// This function only extracts the suffix; it does not validate or interpret\n// the suffix content. Use ParseNumericSuffix, ParseLevelSuffix, etc. for\n// content interpretation.\nfunc ParseSuffix(model string) SuffixResult {\n\t// Find the last opening parenthesis\n\tlastOpen := strings.LastIndex(model, \"(\")\n\tif lastOpen == -1 {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Check if the string ends with a closing parenthesis\n\tif !strings.HasSuffix(model, \")\") {\n\t\treturn SuffixResult{ModelName: model, HasSuffix: false}\n\t}\n\n\t// Extract components\n\tmodelName := model[:lastOpen]\n\trawSuffix := model[lastOpen+1 : len(model)-2]\n\n\treturn SuffixResult{\n\t\tModelName: modelName,\n\t\tHasSuffix: true,\n\t\tRawSuffix: rawSuffix,\n\t}\n}\n\n// ParseNumericSuffix attempts to parse a raw suffix as a numeric budget value.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as an integer.\n// Only non-negative integers are considered valid numeric suffixes.\n//\n// Platform note: The budget value uses Go's int type, which is 32-bit on 32-bit\n// systems and 64-bit on 64-bit systems. Values exceeding the platform's int range\n// will return ok=false.\n//\n// Leading zeros are accepted: \"08192\" parses as 8192.\n//\n// Examples:\n//   - \"8192\" -\u003e budget=8192, ok=true\n//   - \"0\" -\u003e budget=0, ok=true (represents ModeNone)\n//   - \"08192\" -\u003e budget=8192, ok=true (leading zeros accepted)\n//   - \"-1\" -\u003e budget=0, ok=false (negative numbers are not valid numeric suffixes)\n//   - \"high\" -\u003e budget=0, ok=false (not a number)\n//   - \"9223372036854775808\" -\u003e budget=0, ok=false (overflow on 64-bit systems)\n//\n// For special handling of -1 as auto mode, use ParseSpecialSuffix instead.\nfunc ParseNumericSuffix(rawSuffix string) (budget int, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn 0, false\n\t}\n\n\tvalue, err := strconv.Atoi(rawSuffix)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\n\t// Negative numbers are not valid numeric suffixes\n\t// -1 should be handled by special value parsing as \"auto\"\n\tif value \u003c 0 {\n\t\treturn 0, false\n\t}\n\n\treturn value, true\n}\n\n// ParseSpecialSuffix attempts to parse a raw suffix as a special thinking mode value.\n//\n// This function handles special strings that represent a change in thinking mode:\n//   - \"none\" -\u003e ModeNone (disables thinking)\n//   - \"auto\" -\u003e ModeAuto (automatic/dynamic thinking)\n//   - \"-1\"   -\u003e ModeAuto (numeric representation of auto mode)\n//\n// String values are case-insensitive.\nfunc ParseSpecialSuffix(rawSuffix string) (mode ThinkingMode, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn ModeBudget, false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"none\":\n\t\treturn ModeNone, true\n\tcase \"auto\", \"-1\":\n\t\treturn ModeAuto, true\n\tdefault:\n\t\treturn ModeBudget, false\n\t}\n}\n\n// ParseLevelSuffix attempts to parse a raw suffix as a discrete thinking level.\n//\n// This function parses the raw suffix content (from ParseSuffix.RawSuffix) as a level.\n// Only discrete effort levels are valid: minimal, low, medium, high, xhigh.\n// Level matching is case-insensitive.\n//\n// Special values (none, auto) are NOT handled by this function; use ParseSpecialSuffix\n// instead. This separation allows callers to prioritize special value handling.\n//\n// Examples:\n//   - \"high\" -\u003e level=LevelHigh, ok=true\n//   - \"HIGH\" -\u003e level=LevelHigh, ok=true (case insensitive)\n//   - \"medium\" -\u003e level=LevelMedium, ok=true\n//   - \"none\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"auto\" -\u003e level=\"\", ok=false (special value, use ParseSpecialSuffix)\n//   - \"8192\" -\u003e level=\"\", ok=false (numeric, use ParseNumericSuffix)\n//   - \"ultra\" -\u003e level=\"\", ok=false (unknown level)\nfunc ParseLevelSuffix(rawSuffix string) (level ThinkingLevel, ok bool) {\n\tif rawSuffix == \"\" {\n\t\treturn \"\", false\n\t}\n\n\t// Case-insensitive matching\n\tswitch strings.ToLower(rawSuffix) {\n\tcase \"minimal\":\n\t\treturn LevelMinimal, true\n\tcase \"low\":\n\t\treturn LevelLow, true\n\tcase \"medium\":\n\t\treturn LevelMedium, true\n\tcase \"high\":\n\t\treturn LevelHigh, true\n\tcase \"xhigh\":\n\t\treturn LevelXHigh, true\n\tdefault:\n\t\treturn \"\", false\n\t}\n}\n","originalFilePath":"./internal/thinking/suffix.go","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \t// Extract components\n \tmodelName := model[:lastOpen]\n-\trawSuffix := model[lastOpen+1 : len(model)-1]\n+\trawSuffix := model[lastOpen+1 : len(model)-2]\n \n \treturn SuffixResult{\n \t\tModelName: modelName,\n","processOutput":"PASS \"/var/folders/9p/pyr7y33x3_sd4ytlkpp74dnw0000gn/T/go-mutesting-3930694107/./internal/thinking/suffix.go.28\" with checksum 0f58c41be71c9d6083d19a409eac311c\n"}],"errored":null}